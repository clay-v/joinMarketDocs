<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Joinmarket design | JoinMarket Docs</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Make a coinjoin at any time">
    
    <link rel="preload" href="/joinMarketDocs/assets/css/0.styles.47da2780.css" as="style"><link rel="preload" href="/joinMarketDocs/assets/js/app.e0a96047.js" as="script"><link rel="preload" href="/joinMarketDocs/assets/js/2.96e2a3f8.js" as="script"><link rel="preload" href="/joinMarketDocs/assets/js/10.8bb8a683.js" as="script"><link rel="prefetch" href="/joinMarketDocs/assets/js/11.e4445083.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/12.fc2547b9.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/13.908ea9c6.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/14.2f99d1b3.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/15.72679292.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/16.cb0ef4ad.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/17.172e09bc.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/18.ae9324bc.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/19.3db863c1.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/20.90af7f93.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/21.b31423ce.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/22.7969ece1.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/23.ad6d9879.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/24.999ff3b4.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/25.d35fbd9a.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/26.b2e61fcb.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/27.d3754327.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/3.f842ec0d.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/4.cee798b2.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/5.636e11bd.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/6.0af6a184.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/7.0d7dc195.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/8.b445599c.js"><link rel="prefetch" href="/joinMarketDocs/assets/js/9.92136928.js">
    <link rel="stylesheet" href="/joinMarketDocs/assets/css/0.styles.47da2780.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/joinMarketDocs/" class="home-link router-link-active"><!----> <span class="site-name">JoinMarket Docs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/joinMarketDocs/" aria-current="page" class="sidebar-link">Home</a></li><li><section class="sidebar-group depth-0"><a href="/joinMarketDocs/users" class="sidebar-heading clickable"><span>User Guide</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/joinMarketDocs/users/architecture-notes.html" class="sidebar-link">architecture-notes</a></li><li><a href="/joinMarketDocs/users/config-irc-update.html" class="sidebar-link">config-irc-update</a></li><li><a href="/joinMarketDocs/users/fidelity-bonds.html" class="sidebar-link">fidelity-bonds</a></li><li><a href="/joinMarketDocs/users/INSTALL.html" class="sidebar-link">INSTALL</a></li><li><a href="/joinMarketDocs/users/JOINMARKET-QT-GUIDE.html" class="sidebar-link">JOINMARKET-QT-GUIDE</a></li><li><a href="/joinMarketDocs/users/NATIVE-SEGWIT-UPGRADE.html" class="sidebar-link">NATIVE-SEGWIT-UPGRADE</a></li><li><a href="/joinMarketDocs/users/orderbook.html" class="sidebar-link">orderbook</a></li><li><a href="/joinMarketDocs/users/PAYJOIN.html" class="sidebar-link">PAYJOIN</a></li><li><a href="/joinMarketDocs/users/SNICKER.html" class="sidebar-link">SNICKER</a></li><li><a href="/joinMarketDocs/users/SOURCING-COMMITMENTS.html" class="sidebar-link">SOURCING-COMMITMENTS</a></li><li><a href="/joinMarketDocs/users/TODO.html" class="sidebar-link">TODO</a></li><li><a href="/joinMarketDocs/users/TESTING.html" class="sidebar-link">TESTING</a></li><li><a href="/joinMarketDocs/users/tumblerguide.html" class="sidebar-link">tumblerguide</a></li><li><a href="/joinMarketDocs/users/USAGE.html" class="sidebar-link">USAGE</a></li><li><a href="/joinMarketDocs/users/YIELDGENERATOR.html" class="sidebar-link">YIELDGENERATOR</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/joinMarketDocs/developers" class="sidebar-heading clickable router-link-active open"><span>Developer Guide</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/joinMarketDocs/developers/ArchOverview.html" class="sidebar-link">ArchOverview</a></li><li><a href="/joinMarketDocs/developers/High-level-design.html" aria-current="page" class="active sidebar-link">High-level-design</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#purpose-of-this-document" class="sidebar-link">Purpose of this document</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#use-of-external-and-internal-branches" class="sidebar-link">Use of external and internal branches.</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#wallet-object" class="sidebar-link">Wallet object</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#wallet-generation-and-access-control" class="sidebar-link">Wallet generation and access control</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#wallet-persistence" class="sidebar-link">Wallet persistence</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#the-wallet-tool-py-script" class="sidebar-link">The wallet-tool.py script</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#core-concepts" class="sidebar-link">Core concepts</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#joinmarket-transaction-types" class="sidebar-link">Joinmarket transaction types</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#maker" class="sidebar-link">Maker</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#taker" class="sidebar-link">Taker</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#encrypted-messaging" class="sidebar-link">Encrypted messaging</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#messaging-handshake" class="sidebar-link">Messaging handshake.</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#messaging-protocol" class="sidebar-link">Messaging protocol.</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#the-notify-thread" class="sidebar-link">The Notify Thread</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#fee-estimation-calculation" class="sidebar-link">Fee Estimation Calculation</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#public-entity-identities" class="sidebar-link">Public entity identities</a></li><li class="sidebar-sub-header"><a href="/joinMarketDocs/developers/High-level-design.html#orders" class="sidebar-link">Orders</a></li></ul></li><li><a href="/joinMarketDocs/developers/Joinmarket-messaging-protocol.html" class="sidebar-link">Joinmarket-messaging-protocol</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="joinmarket-design"><a href="#joinmarket-design" class="header-anchor">#</a> Joinmarket design</h1> <h2 id="purpose-of-this-document"><a href="#purpose-of-this-document" class="header-anchor">#</a> Purpose of this document</h2> <p>This is a <em>high level</em> description of JoinMarket's design. The goal is to allow developers and other interested parties to either develop for or work with JoinMarket as a system. As an example, it might allow a developer to create a new implementation with an entirely different codebase.</p> <p>Over time, it is hoped that this will be greatly extended - in particular, via linking to sub-documents which give more details on the protocol, such as message formats etc. For example, there is already <a href="https://github.com/JoinMarket-Org/JoinMarket-Docs/blob/master/Joinmarket-messaging-protocol.md" target="_blank" rel="noopener noreferrer">this<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p><strong>Table of Contents</strong></p> <ul><li><p><a href="#wallets">Wallets</a></p></li> <li><p><a href="#use-of-external-and-internal-branches">External and Internal Branches</a></p></li> <li><p><a href="#wallet-object"><code>Wallet</code> object</a></p></li> <li><p><a href="#wallet-generation-and-access-control">Wallet generation and access control</a></p></li> <li><p><a href="#wallet-persistence">Wallet persistence</a></p></li> <li><p><a href="#the-wallet-toolpy-script"><code>wallet-tool.py</code></a></p></li> <li><p><a href="#transactions">Transactions</a></p></li> <li><p><a href="#core-concepts">Core concepts</a></p></li> <li><p><a href="#joinmarket-transaction-types">Joinmarket transaction types</a></p></li> <li><p><a href="#entities">Entities</a></p></li> <li><p><a href="#maker">Maker</a></p></li> <li><p><a href="#taker">Taker</a></p> <ul><li><p><a href="#the-sendpayment-script">sendpayment</a></p></li> <li><p><a href="#the-tumbler-script">tumbler</a></p></li></ul></li> <li><p><a href="#messaging-layer">Messaging Layer</a></p></li> <li><p><a href="#encrypted-messaging">Encrypted messaging</a></p></li> <li><p><a href="#messaging-handshake">Messaging handshake</a></p></li> <li><p><a href="#messaging-protocol">Messaging protocol</a></p></li> <li><p><a href="#blockchain-interface">Blockchain Interface</a></p></li> <li><p><a href="#the-notify-thread">The Notify Thread</a></p></li> <li><p><a href="#bitcoin-transaction-fees">Bitcoin Transaction Fees</a></p></li> <li><p><a href="#orders-and-the-trading-pit">Orders and the trading pit</a></p></li> <li><p><a href="#public-entity-identities">Public entity identities</a></p></li> <li><p><a href="#orders">Orders</a></p></li> <li><p><a href="#the-configuration-file">The Configuration File</a></p></li></ul> <h1 id="wallets"><a href="#wallets" class="header-anchor">#</a> Wallets</h1> <p>Joinmarket wallets are of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener noreferrer">BIP32 Hierarchical Deterministic wallet<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> form, starting from the root m/0 (here '0' marks the default account, in accordance with the BIP spec). The branches are defined by:</p> <div class="language- extra-class"><pre><code>m/0/mixdepth/[external/internal]
</code></pre></div><p>The value of mixdepth runs from 0..M-1, where M is the number of mixdepths chosen by the user; by default 5. The value of [external/internal] is 0 for external, 1 for internal. Thus a default wallet will contain 10 separate branches.</p> <p>Note that all of the keys are of the non-hardened type.</p> <p>Typical output from script <code>wallet-tool.py</code>, which enables basic wallet handling, running against a testnet wallet seed:</p> <div class="language- extra-class"><pre><code>mixing depth 0 m/0/0/
 external addresses m/0/0/0/
  m/0/0/0/016 muijch3wHvCXm9pHJQiyQFWDZSngPUdLrB  new 0.00000000 btc 
  m/0/0/0/017 n35T2GFV2CQXuN2eZJWBG7GTkhJZs4swJD  new 0.00000000 btc 
  m/0/0/0/018 mgwSKYK1zssnJi5T9UaR1gxdzPmU6zobvk  new 0.00000000 btc 
  m/0/0/0/019 mmXouP3x92h5yvBLMn6So4BvTRShN318Za  new 0.00000000 btc 
  m/0/0/0/020 mhKpprCpmfnsS2AwBDjiRoArNjSRMKCXHL  new 0.00000000 btc 
  m/0/0/0/021 n1h6MYPJLsoJ1dz2HNGxM7L5ct4A84RvQW  new 0.00000000 btc 
 internal addresses m/0/0/1/
  m/0/0/1/048 mrytep7Ne1t2Epzrn1zWPrBAfaDWCtekqx used 4.87792833 btc 
for mixdepth=0 balance=4.87792833btc
mixing depth 1 m/0/1/
 external addresses m/0/1/0/
  m/0/1/0/045 mrjkGaHdvFqZiTXRWcvAqSTmLaxKRfDWB9 used 9.27910795 btc 
  m/0/1/0/046 mmMs5iHLZKaLHLG3zysHwEdBNVHGyCLXgf  new 0.00000000 btc 
  m/0/1/0/047 mfkPoc34Z2k15jhcwPc8ifywykXvkovv9z  new 0.00000000 btc 
  m/0/1/0/048 mn5AuW8due3KtTGXvi68xQQUyNkg8jo5uQ  new 0.00000000 btc 
  m/0/1/0/049 n4Wg3ajPgLvEpumK2sHZXiggUw3kX6XCSh  new 0.00000000 btc 
  m/0/1/0/050 mfnxp5n4nMa9fZogNBo5gTSA7HBRLYmCW2  new 0.00000000 btc 
  m/0/1/0/051 msRJ7MpC9gKjqi7GjJ8WrHqAnPwDT8Nxsc  new 0.00000000 btc 
 internal addresses m/0/1/1/
  m/0/1/1/043 mtBYHv4vmxKfqQT2Cr2vrA578EmUzcwwKA used 1.76456658 btc 
  m/0/1/1/044 mp9yvRWwu5Lcs5EAnvGSKMKWith2qv1Rxt used 4.58622784 btc 
for mixdepth=1 balance=15.62990237btc
mixing depth 2 m/0/2/
 external addresses m/0/2/0/
  m/0/2/0/042 muaApeqh9L4aQvR6Fn52oDiqz8jKKu9Rfz  new 0.00000000 btc 
  m/0/2/0/043 mqdZS695VHeNpk83YtBmutGFNcJsPC39wW  new 0.00000000 btc 
  m/0/2/0/044 mq32QZX7DszZCYzKP6TvZRom1xFMoUWkbS  new 0.00000000 btc 
  m/0/2/0/045 mterWqVTyj2oKHPr1raaY6iwqQTKbwM5ro  new 0.00000000 btc 
  m/0/2/0/046 mzaotzzCHvoZxs2RjYXWN2Yh9kB6F5gU8j  new 0.00000000 btc 
  m/0/2/0/047 mvJMCGoG5ZUARtAr5x2KD1ebNLuL618zXU  new 0.00000000 btc 
 internal addresses m/0/2/1/
for mixdepth=2 balance=0.00000000btc
mixing depth 3 m/0/3/
 external addresses m/0/3/0/
  m/0/3/0/002 mwjZyUbh78UndNtqsKathxpjE4EsYrhLzm used 3.00000000 btc 
  m/0/3/0/004 msMoHnZRKfNRPQqg2MUk1rXrqwM6VeLL8C used 0.30000000 btc 
  m/0/3/0/006 mhBHRaFwMTPPWLdukqgJaSMmmCeQ8ef6QV used 9.26824652 btc 
  m/0/3/0/007 mrdv38dX1eQsZjAof442G9Lj66bM5yUnjA used 4.58134572 btc 
  m/0/3/0/008 moWA3FEYkNbEJkHdnQbQYkrVztTviMaHwe used 5.39567085 btc 
  m/0/3/0/009 mgoTGzD46mWoMiH97QHh9TxuJp4NmVobNp used 3.00000000 btc 
  m/0/3/0/010 mjddF8HmBaenGBspTMzhF3qikbbLB4xGZN  new 0.00000000 btc 
  m/0/3/0/011 mnEvKc2JLj8s1GLfvtvqVt5pWTu5jCdtEk  new 0.00000000 btc 
  m/0/3/0/012 n1FwKgDEjzRj2YsZNoG5MWVnuq72wA8Mgr  new 0.00000000 btc 
  m/0/3/0/013 mq4vn4KX9SRrvhiRkg9KrYADhKNPAp2wyN  new 0.00000000 btc 
  m/0/3/0/014 n3nG4334F19THUACgEEveRX8JcE5awY1qz  new 0.00000000 btc 
  m/0/3/0/015 mz5yHHbud68b8CLeNk2MsnyFgSJ9rPGk7v  new 0.00000000 btc 
 internal addresses m/0/3/1/
  m/0/3/1/000 mfbeMyajM4wYRmpWVrYnd3rBqvtBniw8gj used 0.25672994 btc 
  m/0/3/1/001 mzkFk3C9J6D9KE9cV4kuSctUKZXkr1gaio used 0.51499000 btc 
  m/0/3/1/002 n3SCTwDs4wcn7yGhFq8HJwxQ9PzBXvTJdV used 0.04199000 btc 
  m/0/3/1/006 mow4CyHNssjo2CNHdg3DdbXWYNPfY8HEPe used 0.36073270 btc 
for mixdepth=3 balance=26.71970573btc
mixing depth 4 m/0/4/
 external addresses m/0/4/0/
  m/0/4/0/011 mzMWwUSvj4n3wgtSMLXt17hQTi2zinzYWZ used 2.00000000 btc 
  m/0/4/0/012 mrgNjQWjrBDB821o1Q3qG6EmKJmEqgjtqY  new 0.00000000 btc 
  m/0/4/0/013 msjynFwGoGePoheVABAEgjxjw8FNuPgtPC  new 0.00000000 btc 
  m/0/4/0/014 moJpd6ZvgAm1ZENmAuoPKnqAUntoSixao9  new 0.00000000 btc 
  m/0/4/0/015 muajyWxmjuHQDm3MpSr7Y3RLAWDqch1yix  new 0.00000000 btc 
  m/0/4/0/016 n2tPijSN4nBFGAKbXpp6H7hfznhsYWwR88  new 0.00000000 btc 
  m/0/4/0/017 mnkrhe7fMYy4yjPM54gEurgxWpDXJ3axtn  new 0.00000000 btc 
 internal addresses m/0/4/1/
for mixdepth=4 balance=2.00000000btc
total balance = 49.22753643btc
</code></pre></div><p>Balances displayed by <a href="#the-wallet-toolpy-script"><code>wallet-tool.py</code></a> <strong>include unconfirmed amounts</strong> by default. This (i.e. treating unconfirmed coins as available) is <strong>not currently supported</strong> when running <a href="#entities">bot entities</a>, based on the problematic nature of spending unconfirmed coins, but can be done by editing configuration. For details on the fine-grained control over what conis are considered available, see the advice in the default version of <code>joinmarket.cfg</code> that is held in the file <code>configure.py</code>.</p> <h2 id="use-of-external-and-internal-branches"><a href="#use-of-external-and-internal-branches" class="header-anchor">#</a> Use of external and internal branches.</h2> <p>Payments into the wallet should be made into new addresses on the <code>external</code> branch for any mixdepth. For the above wallet, <code>muaApeqh9L4aQvR6Fn52oDiqz8jKKu9Rfz</code> (from mixdepth 2) or <code>mrgNjQWjrBDB821o1Q3qG6EmKJmEqgjtqY</code> (from mixdepth 4) would be suitable candidates. The index of the address on the branch is shown as the final 3 digit integer in the identifier. As usual with deterministic wallets, a configurable gap-limit variable is used to determine how far forwards to search after unused/new addresses are located.</p> <p>In joinmarket <a href="#transactions">transactions</a>, a single destination output goes to the address designated by the transaction initiator (which need not be an address in a joinmarket wallet; it could be any valid Bitcoin address, including P2SH). The remaining outputs go to internal addresses as follows:</p> <ul><li>If the transaction initiator has any change left (&quot;sweep&quot; transactions send a precise amount, without leaving change), it is sent to a new address in the internal branch of the same mixdepth as the initiator's inputs.</li> <li>Each liquidity provider sends a single change output to a new address in the same mixdepth as its inputs.</li> <li>Each liquidity provider sends a single output (with size identical to that of the destination output) to a new address in the next mixdepth, wrapping back to the first (that is, the mixdepth in BIP32 branch zero) upon reaching <code>max_mix_depth</code>.</li></ul> <p>The logic of this is fairly straightforward, and central to how Joinmarket works, so make sure to understand it: <strong>the coinjoin outputs of a transaction must not be reused with any of the inputs to that same transaction, or any other output that can be connected with them, as this would allow fairly trivial linkage</strong>. Merging such outputs is avoided by picking the inputs for a transaction only from a single mixdepth (although both internal and external branches can be used).</p> <h2 id="wallet-object"><a href="#wallet-object" class="header-anchor">#</a> <code>Wallet</code> object</h2> <p>The <code>Wallet</code> class is found in the module <code>joinmarket.wallet</code>. Its member variables, which are persisted to disk, are:</p> <div class="language- extra-class"><pre><code>addr_cache
unspent
seed
gaplimit
keys
index
</code></pre></div><p><strong>addr_cache</strong> is a dict, with each entry of format <code>Bitcoin address: (mixing depth, external/internal flag, index)</code>. The external/internal flag is 0/1 and the index is the index of the address on the branch. Note that the address itself <strong>is not</strong> persisted, only the index of the first unused key (and address) on each specific branch (see <a href="#wallet-persistence">here</a>).</p> <p><strong>unspent</strong> is a dict, with each entry of format <code>utxo: {'address': address, 'value': amount in satoshis}</code>, where <code>utxo</code> has format txid:n as usual in Bitcoin wallets. This is the fundamental data structure that Joinmarket uses to decide which coins to spend in joins.</p> <p><strong>seed</strong> is the master secret of the BIP32 wallet. See <a href="#wallet-generation-and-access-control">this section</a> for more details.</p> <p><strong>gaplimit</strong> is used to decide how many addresses to search forwards (through unused addresses on a branch) before giving up and assuming no more addresses on that branch have been used. This is as usual for HD wallets; the default value is 6.</p> <p><strong>keys</strong> is a list of pairs of parent keys that are used to generate the individual branches, i.e. it has the form: <code>[(key for mixdepth 0 external branch, key for mixdepth 0 internal branch), (key for mixdepth 1 external branch, key for mixdepth 1 internal branch), ...]</code></p> <p>TODO: add documentation on using imported keys.</p> <p><strong>index</strong> this (too generically named!) is a list of pairs of pointers into each of the branches, marking the first unused address in that branch, format <code>[[a,b],[c,d]...]</code> with each letter standing for a positive integer. Note that this <strong>is</strong> <a href="#wallet-persistence">persisted</a> to file storage to prevent address reuse in case of failures.</p> <h2 id="wallet-generation-and-access-control"><a href="#wallet-generation-and-access-control" class="header-anchor">#</a> Wallet generation and access control</h2> <p>The master private key is generated via a call to Python's <code>os.urandom</code>, this being the interface to the underlying OS randomness source. It is then passed through two rounds of SHA256. It is a 32 byte random string (which is the advised seed length for BIP32).</p> <p>This seed is used to generate the wallet structure described above and according to the BIP32 specification.</p> <p>The recovery seedphrase is a 12 word phrase of the type used in earlier versions of Electrum, and using that code base, specifically see the functions <code>mn_encode</code> and <code>mn_decode</code> in the module <code>old_mnemonic.py</code>, which uses a 1626 word list, also found in that file (note: 1626<sup>12</sup> implies 128 bit security). A commonly asked question is whether and why not Joinmarket supports BIP39. For now, the answer to that question is that it isn't relevant; since JM's wallet uses this specific HD structure, designed to allow coinjoins to occur safely, it is not directly compatible with other wallets. This may change in the future, however.</p> <p>The wallet seed is encrypted for persistent storage using AES in CBC mode, using the module <code>slowaes.py</code>. Note that a bug was found earlier in this module's handling of PKCS7, which could have allowed 'decryption' with a wrong password (to garbage), but this was <a href="https://github.com/JoinMarket-Org/joinmarket/pull/191" target="_blank" rel="noopener noreferrer">fixed<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h2 id="wallet-persistence"><a href="#wallet-persistence" class="header-anchor">#</a> Wallet persistence</h2> <p>The wallet is persisted to disk in this format:</p> <div class="language- extra-class"><pre><code>{&quot;index_cache&quot;: [[113, 163], [149, 161], [154, 134], [128, 149], [135, 120]], &quot;encrypted_seed&quot;:
&quot;15336f8220ee6da168c153e1e11c0402c862fa377d2422c27b5f92ed37d52a840d1a80c4eda7ca9731ec5e0ebfa92cdd&quot;,
&quot;creation_time&quot;: &quot;2015/05/08 15:56:58&quot;, &quot;network&quot;: &quot;mainnet&quot;, &quot;creator&quot;: &quot;joinmarket project&quot;}
</code></pre></div><p><strong>index_cache</strong> is a list of 5 x 2 entries, one for each branch in the wallet (in the default case) as described above. Each number is a pointer to the next unused address on the branch. This is of high importance because it allows the entity in control of the wallet to ensure that an address on that branch is not reused in more than one transaction. To achieve this, it's necessary that the function <code>Wallet.update_index_cache</code> is called <em>immediately</em> a new transaction is <em>proposed</em> for that entity, even if the transaction fails to complete. Note that this can lead to practical difficulties (such as large wallet gaps) in the case of Sybil attacks or errors where a long string of proposed but incompleted transactions occurs.</p> <p><strong>encrypted_seed</strong> is a 48 byte hex encoded string - this is 3 AES blocks, the plaintext being the 32 byte seed, the final block's plaintext being entirely pkcs7 padding.</p> <p><strong>creation_time</strong>, <strong>network</strong> and <strong>creator</strong> are self-explanatory.</p> <p>Wallet persistence to disk only occurs in these scenarios: when using <a href="#the-wallet-toolpy-script"><code>wallet-tool.py</code></a>, either generating a wallet or importing keys, and in the initialisation of the <code>CoinJoinOrder</code> object, which calls <code>update_cache_index()</code> method of the <code>Wallet</code> object (to prevent address reuse).</p> <p>However, it's important to remember that the Bitcoin blockchain itself is another deeper layer of persistence; on starting a <code>Maker</code> or <code>Taker</code> bot, the wallet's <code>unspent</code> variable is updated by querying the <code>sync_unspent</code> method of the <code>BlockchainInterface</code> instance (see <a href="#blockchain-interface">Blockchain Interface</a>).</p> <h2 id="the-wallet-tool-py-script"><a href="#the-wallet-tool-py-script" class="header-anchor">#</a> The <code>wallet-tool.py</code> script</h2> <p>This script is currently (may change after GUI tools are developed) the way a user can perform two functions: (a) generating, recovering and funding a wallet, and (b) viewing a wallet's status. See <code>--help</code> for an explanation of its features.</p> <h1 id="transactions"><a href="#transactions" class="header-anchor">#</a> Transactions</h1> <h2 id="core-concepts"><a href="#core-concepts" class="header-anchor">#</a> Core concepts</h2> <p>The basic idea of CoinJoin is explained in detail <a href="https://bitcointalk.org/index.php?topic=279249.msg2983902#msg2983902" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. JoinMarket transactions are of the simplest type described there: there is one coordinating party (the <em>taker</em>) who combines his own inputs with inputs from many <em>makers</em> and produces a template of a transaction with N+1 <strong>equal</strong> outputs (of a size decided by the taker), one for each maker plus himself, and as many change outputs as are required. In the current Joinmarket implementation, there is one change for each participant, except (a) if the taker has deliberately chosen to spend all of his inputs to the coinjoin output, see <a href="#sweepjmtx">sweeps</a>, or (b) in rare cases, by accident, one maker has exactly the right amount in his inputs for the coinjoin output.</p> <p>After constructing the template transaction, the taker broadcasts the template to the makers, who transfer valid signatures back to the taker. The taker then adds his own signatures and broadcasts the bitcoin transaction.</p> <p>This design allows for change outputs for maximum practicability. Insisting on <em>only</em> equal sized outputs (only &quot;coinjoin outputs&quot; in this terminology) would considerably improve privacy benefits but makes coordinating to achieve the goal nearly impossible.</p> <p>Critical to making this work effectively is avoiding <strong>address reuse</strong>. If coinjoin outputs later get reused with change outputs that link back to either the inputs, or the change outputs, in the same transaction, then the coinjoin output can be linked to them, destroying the purpose of the transaction. For this reason, Joinmarket <a href="#wallets">wallets</a> use a BIP32 hierarchical deterministic structure and enforce that the coinjoin outputs are on a different branch than the inputs and change outputs.</p> <p>The next section shows the basic types of transaction that can occur in JoinMarket and illustrate these points in a more concrete fashion.</p> <h2 id="joinmarket-transaction-types"><a href="#joinmarket-transaction-types" class="header-anchor">#</a> Joinmarket transaction types</h2> <p>We can define 4 distinct joinmarket transaction types. We use the notation &quot;JMTx&quot; for all of these, and separate short hand versions for each one.</p> <ol><li><p>SourceJMTx
This is usually an ordinary bitcoin transaction paying into an unused address on an external branch for any one of the mixdepths of the wallet. As such it has no special joinmarket structure; it will usually have a change output, which will go back to the wallet funding this one. It <em>could</em>, however, be a payment from another joinmarket wallet, although most users will not be using more than one joinmarket wallet. This doesn't affect the analysis, in any case.</p></li> <li><p>(Canonical) CJMTx
The most fundamental type of joinmarket transaction involves neither a 'source' nor a 'sink', but only spends from this joinmarket wallet to itself, in conjunction with joining counterparties. The coinjoin output goes to a new address on the internal branch of the <em>next</em> mixdepth, as was described in the previous section.</p></li></ol> <p><img src="/images/CJMTx.png" alt="alt text"></p> <p><strong>NOTE</strong>: the above diagram ignores transaction fees and coinjoin fees for simplicity, which slightly change the size of the change outputs; this obviously cannot be ignored in real analysis.</p> <ol start="3"><li><p>SpendJMTx
This is a 'sink' transaction. This, generated either by <code>sendpayment.py</code> or <code>tumbler.py</code> scripts usually, will be the same as the CJMTx above, except with the difference that the coinjoin output for the initiator (taker) goes to an address from another wallet, e.g. a payment or a transfer to an external wallet.</p></li> <li><p>SweepJMTx
This can be either a 'sink' or not, depending on the destination of the coinjoin output. A sweep is characterised by 2 things: (a) the initiator will not create a change output, and (b) the initiator will consume <strong>all</strong> of the utxos in the given mixdepth (both internal and external branches) as inputs, leaving no coins left in that mixdepth.</p></li></ol> <p><img src="/images/SweepJMTx.png" alt="alt text"></p> <hr> <h1 id="entities"><a href="#entities" class="header-anchor">#</a> Entities</h1> <p>All entities are subclassed from <code>CoinJoinerPeer</code>, which has the instance member <code>self.msgchan</code>. This is an instance of class <code>MessageChannel</code>, which abstracts the functionality required for the peer to participate in the communications channel.</p> <p>There are currently three types of <code>CoinJoinerPeer</code>:</p> <ol><li><code>OrderbookWatch</code></li> <li><code>Taker</code></li> <li><code>Maker</code></li></ol> <p><code>OrderbookWatch</code> does not participate in the Joinmarket protocol, but is an abstraction to allow observation of the Joinmarket pit. It stores order information in a sqlite3 db object.</p> <p><code>Taker</code> extends from <code>OrderbookWatch</code>, inheriting the db object for querying orders in the joinmarket pit, allowing the taker to make decisions about which orders to fill. Maker inherits directly from <code>CoinJoinerPeer</code> since it does not need this information.</p> <p>The required functionality of <code>Taker</code> and <code>Maker</code> objects is described in the succeeding sections.</p> <hr> <h2 id="maker"><a href="#maker" class="header-anchor">#</a> Maker</h2> <p>Existing instances: <code>yield-generator-basic.py</code>, <code>yield-generator-mixdepth.py</code>, <code>yield-generator-deluxe.py</code>, <code>patientsendpayment.py</code></p> <p>A Joinmarket maker offers liquidity for coinjoins (hence the terminology, borrowed from financial exchanges - <em>liquidity maker</em>). At a high level, it offers this functionality:</p> <ul><li>Enter the joinmarket trading pit, using the functionality provided by the <code>self.msgchan</code> instance variable.</li> <li>Announce information about the parameters for coinjoins it is willing to carry out - amounts, fees.</li> <li>Wait until a <code>Taker</code> requests a coinjoin</li> <li>Participate in a handshake to set up the coinjoin transaction</li> <li>Provide the <code>Taker</code> with signatures for an agreed upon coinjoin transaction</li> <li>Watch the blockchain for updates, updating its state (including wallet) when a transaction appears.</li></ul> <h3 id="publishing-orders"><a href="#publishing-orders" class="header-anchor">#</a> Publishing orders</h3> <p>A Maker is by definition an entity that broadcasts its availability to do coinjoins. It published what are called <a href="#orders">orders</a> - but note that functionally these are <em>offers</em>.</p> <h3 id="design-considerations"><a href="#design-considerations" class="header-anchor">#</a> Design considerations</h3> <p>As can be seen, a maker offers a service, so after the message channel is set up, its methods get triggered by callbacks from the main listening loop in the messaging channel. The startup process is, at a high level, :</p> <ul><li>Parse command line and load configuration from <code>joinmarket.cfg</code></li> <li>load wallet</li> <li>initialize message channel and register callbacks</li> <li>start message channel listening loop</li></ul> <p>Once a request is received from a taker, the maker creates a new <code>CoinJoinOrder</code> object instance, and this performs the handshake, initializes encryption on the messaging channel, and exchanges the data for the transaction. Then, a listening thread is set up to listen for <strong>announcement of the new bitcoin transaction on the network</strong> (see <code>unconfirm_callback</code>), and for <strong>inclusion of the bitcoin transaction in a block</strong> (see <code>confirm_callback</code>).</p> <p><strong>NB: Handling concurrent requests:</strong> If two takers attempt to fill the same order at once, the maker will <strong>not</strong> lock the utxos immediately a request is initiated, but will mark those utxos as consumed as soon as the <code>unconfirm_callback</code> is triggered (i.e. the negotiated transaction is seen on the bitcoin network). A little reflection will show that this is the only design that makes sense. After a taker has negotiated a transaction, he is under no obligation to actually broadcast it to the bitcoin network, nor is he certain to have received the right signatures from all other makers (they may have crashed, or dropped off the network, or sent garbage signatures, etc.). So this maker has no particular reason to expect that the transaction will ever be broadcast. Even worse, a taker may deliberately DOS attack makers by requesting transactions and then not broadcasting. Hence, it's necessary that makers do not mark utxos as &quot;used&quot; until and unless they see the negotiated transaction broadcast. This <em>does</em> create a slightly unfortunate fact that two takers who successfully negotiate different transactions using this maker's utxos are in a race to broadcast them, but this is unavoidable.</p> <p><strong>Keeping track of state for individual takers</strong>: A maker will only perform one transaction for one particular taker at a time. The instance variable <code>self.active_orders</code> is a dict for which the keys are the names of taker counterparties, and the values are <code>CoinJoinOrder</code> objects, each of which contains a <code>libnacl.public.Box</code> object used for encrypted messaging with that counterparty. If a taker tries to start a new transaction while a previous one is incomplete, the new <code>CoinJoinOrder</code> overwrites the old one (and a new encryption Box is set up).</p> <h3 id="the-coinjoinorder-object"><a href="#the-coinjoinorder-object" class="header-anchor">#</a> The CoinJoinOrder object</h3> <p>The <code>CoinJoinOrder</code> object is perhaps poorly named; it manages the process of negotiating a single transaction with a taker for this maker, once a order fill request has been received. See <a href="https://github.com/Joinmarket-Org/joinmarket-docs/blob/master/encryption_protocol.txt" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for the steps of negotiation.</p> <p>If the negotiation is successful from the maker's point of view, it will add a notification function to the list <code>txnotify_fun</code> in the <code>BlockchainInterface</code> instance, and thus register callbacks <code>unconfirm_callback</code> and <code>confirm_callback</code> for this transaction.</p> <h3 id="unconfirm-and-confirm-callbacks-for-a-coinjoinorder-object"><a href="#unconfirm-and-confirm-callbacks-for-a-coinjoinorder-object" class="header-anchor">#</a> Unconfirm and confirm callbacks for a <code>CoinJoinOrder</code> object</h3> <p>When an unconfirmed transaction is seen on the network (as justified above), the wallet state must be updated to remove those utxos, and the orders that the maker is offering should change. This is done by calling <code>Maker.modify_orders</code> and passing the delta to existing orders, which is calculated by the algorithm the maker is using (so, this is a function of the maker's algorithm). That delta is found by calling <code>Maker.on_tx_confirmed</code> and <code>Maker.on_tx_unconfirmed</code> - note that these methods will be overriden by subclasses (at the moment, <code>YieldGenerator</code>). Utxos will also be added, of course, in calling <code>on_tx_confirmed</code> - the newly created ones.</p> <hr> <h2 id="taker"><a href="#taker" class="header-anchor">#</a> Taker</h2> <p>Existing instances: <code>sendpayment.py</code>, <code>tumbler.py</code>, <code>patientsendpayment.py</code></p> <p>A joinmarket taker chooses a set of makers, based on examination of the orderbook, and initiates a coinjoin transaction, and broadcasts it to the network. It may choose to do this repeatedly. At a high level, its functionality looks like this:</p> <ul><li>Enter the joinmarket trading pit, using the functionality provided by the <code>self.msgchan</code> instance variable.</li> <li>Request the orderbook and store this information in its <code>self.db</code> instance variable.</li> <li>Decide which subset of orders it wants to fill based on amounts, fees and its own configuration/algorithm.</li> <li>Initiate the handshake and transaction data transfer with the chosen set of makers.</li> <li>Create the template of the intended coinjoin transaction and send to the makers.</li> <li>Wait until it has received all the signatures for the agreed upon coinjoin transaction</li> <li>Serialize the final transaction and broadcast it to the bitcoin blockchain via the <code>BlockchainInterface</code>, then:</li> <li>Quit, OR</li> <li>Watch the blockchain for updates, updating its state (including wallet) when a transaction appears, then:</li> <li>loop back to 'request the orderbook' above, in order to start the next transaction in the series.</li></ul> <h3 id="design-considerations-2"><a href="#design-considerations-2" class="header-anchor">#</a> Design considerations</h3> <p>Although a taker is a <em>consumer</em> of service rather than a provider, nevertheless it has the same basic architecture as a maker: after the message channel is set up, its methods get triggered by callbacks from the main listening loop in the messaging channel. So the startup process is basically identical to that listed above for the maker.</p> <p>Whether the taker initiates one transaction or many, once it has broadcast its final transaction, it simply quits. For a series of transaction, it uses the same design as the maker to listen for blockchain events: it adds <code>unconfirm_callback</code> and <code>confirm_callback</code> to its <code>BlockchainInterface</code> instance. Since there is no competition for its utxos, there is no need for specific actions in response to transaction arrival on the bitcoin network, so <code>unconfirm_callback</code> need not do anything (except perhaps print debugging information), but the <code>confirm_callback</code> can be used to trigger the next transaction in the taker's chosen sequence of transactions, and also requires update of the wallet state to refer to the new utxos.</p> <h3 id="the-coinjointx-object"><a href="#the-coinjointx-object" class="header-anchor">#</a> The <code>CoinJoinTX</code> object</h3> <p>This plays a similar role to <code>CoinJoinOrder</code> for <code>Maker</code>. A taker only processes one <code>CoinJoinTx</code> object at a time, and its process is initiated in the constructor. When a taker is ready to initiate a transaction with a decided-on set of makers, it calls <code>Taker.start_cj()</code> with arguments specifying its chosen orders (from makers), coinjoin amount, output addresses, utxos and transaction fee and then initiates a handshake, sets up encryption, transfers transaction data, receives signatures and then signs itself and pushes the transaction to the bitcoin network.</p> <h3 id="handling-unresponsive-makers"><a href="#handling-unresponsive-makers" class="header-anchor">#</a> Handling unresponsive makers</h3> <p>It is not uncommon for the makers to fail to respond at any stage of transaction negotiation. To handle this, the <code>CoinJoinTX</code> object contains a <code>TimeoutThread</code> which keeps track of how long we've been waiting for all of the makers specified for the transaction. If the timeout (specified in the configuration variable <code>maker_timeout_sec</code>) is exceeded, the function <code>CoinJoinTX.recover_from_nonrespondants()</code> is called, allowing the taker to restart the process from the beginning.</p> <p>Note that it is also possible to manually specify makers with which the taker does not want to join, by amending the <code>ignored_makers</code> list. This is not currently part of the configuration and is not expected to be needed, usually.</p> <h3 id="taker-implementations"><a href="#taker-implementations" class="header-anchor">#</a> Taker implementations</h3> <p>For each of these, please see the user instructions specified in the output of <code>python scriptname.py --help</code>.</p> <h4 id="the-sendpayment-script"><a href="#the-sendpayment-script" class="header-anchor">#</a> The sendpayment script</h4> <p>This is designed to implement the simplest scenario for a <code>Taker</code> : it starts, does one coinjoin, then quits. The expected functionality is as follows.</p> <p>For the sequence of events, see the bullet point list in <a href="#taker">Taker</a>, bearing in mind that this is the only-one-coinjoin option.</p> <p>The syntax is:</p> <div class="language- extra-class"><pre><code>python sendpayment.py [options] [wallet file] [amount] [destaddr]
</code></pre></div><p>To carry out a <em>sweep</em> (see item 4 in <a href="#joinmarket-transaction-types">joinmarket transaction types</a>), the field <code>amount</code> must be set to zero. For other transactions, the amount must be specified in satoshis.</p> <p>The <code>destaddr</code> is the address which will receive the coinjoin amount (the amount specified in <code>amount</code>). Note that specifying a non-p2pkh address (i.e. a p2sh address, usually for multisig - addresses starting with '3' on the main bitcoin network) is highly inadvisable, as it allows immediate linkage of that coinjoin output to the input and change address.</p> <p>The default mixdepth from which the spend will occur is mixdepth 0. Otherwise, the user must specify the mixdepth with the <code>-m</code> flag.</p> <p>The user also specifies the number of counterparties with which to join. Choosing -N 1 is not recommended since this allows the counterparty to know the taker's destination address. The default is 2, but numbers from 3-5 are probably most suitable. Larger figures suffer from larger transaction fees, as well as potential unreliability problems.</p> <p>Once the configuration has been set, the sendpayment script starts a <code>PaymentThread</code> thread object, which does the following:</p> <p>First, it extracts the list of available orders from its internal <code>self.db</code> object. Then, it estimates the bitcoin transaction fee (see the separate <a href="#bitcoin-transaction-fees">section</a>).</p> <p>Next, the most important part of the code is the method of choosing which orders, read from the orderbook, are to be used for the construction of the join transaction. See the functions <code>sendpayment_choose_orders</code> in <code>sendpayment.py</code> and <code>choose_sweep_orders</code> in <code>support.py</code>. Within these functions, the ranking of orders is performed by one of three functions found in <code>support.py</code>:</p> <ul><li>pick_order</li> <li>cheapest_order_choose</li> <li>weighted_order_choose</li></ul> <p>with the last of the three being the default. The logic behind the default is deferred to a separate <a href="#weighted-orders-choose">section</a>. Also note that <code>pick_order</code> cannot be used in conjunction with sweeping.</p> <p>Once the set of orders has been chosen and the fees set (and the coinjoin amount, for sweeps), the process continues as described above for Takers, i.e. <code>Taker.start_cj</code> is called with the defined parameters. The remaining execution is handled by the <code>CoinJoinTX</code> object.</p> <p><strong>Pseudocode</strong></p> <div class="language- extra-class"><pre><code>function do_sendpayment(sweep):
 load wallet
 start msgchan
 read orders from pit
 set transaction fee estimate(sweep)
 choose orders using chosen algo (sweep)
 send !fill message to chosen counterparties and do encryption handshake
 receive utxos
 construct template transaction and send to all counterparties
 receive signatures
 broadcast transaction to bitcoin network
 quit
</code></pre></div><p>The parameter 'sweep' is used here to illustrate the fact that two parts of the processing are different dependent on whether the transaction is of the sweep type (<em>sweepjmtx</em>) or not - in which case it is the canonical type (<em>cjmtx</em>).</p> <p><strong>Different logic for sweeps</strong>: Sweep transactions have a small but technically very significant additional complexity: the transaction <em>amount</em>, i.e. the amount used for the coinjoin amount, is not known <em>until the list of orders is chosen</em>. This is because until the list of counterparty (maker) orders is chosen, the total coinjoin fee is not known (since each maker specifies their own coinjoin fee, and contribution to the total bitcoin transaction fee). The code handles this problem in the <code>choose_sweep_orders</code> function in <code>support.py</code>. It does this in an iterative process: first, the set of available orders is constructed. Then, each order is selected one by one based on the choose_orders algorithm the user preferred (which must be one of <code>weighted_order_choose</code> or <code>cheapest_order_choose</code>). Multiple orders from the same counterparty are rejected. Then, the coinjoin amount is calculated so as to leave zero change. Finally, each order in the chosen set is examined to see whether the newly calculated coinjoin amount is within its <code>minsize</code> and <code>maxsize</code> parameters. If not, that order is removed from the list, and the iteration continues until <em>all</em> chosen orders match with the calculated coinjoin size.</p> <p>The extra logic for bitcoin transaction fee handling for sweeps is covered in the bitcoin transaction fee <a href="#bitcoin-transaction-fees">section</a>.</p> <h4 id="the-tumbler-script"><a href="#the-tumbler-script" class="header-anchor">#</a> The tumbler script</h4> <p>This is designed to allow a <code>Taker</code> to heavily (if not perfectly) delink the coins in the wallet by means of a long sequence of coinjoins. The expected functionality is as follows.</p> <p>For the basic sequence of events, see the bullet point list in <a href="#taker">Taker</a>, bearing in mind that this is the multiple-coinjoin option.</p> <p>The syntax is:</p> <div class="language- extra-class"><pre><code>python tumbler.py [options] [wallet file] [destaddr1] [[destaddr2] ...]
</code></pre></div><p>By default, the tumbler will follow the steps listed below. In this <code>cjmtx</code> and <code>sweepjmtx</code> are as mentioned above for sendpayment.</p> <ul><li>User provides 1 or more addresses (the default is 3, although they can be added during the tumbler run) for payment along with several other configuration variables. See <code>--help</code> for this (long!) list of options.</li> <li>Starting from one mixdepth (by default 0), follow these steps for each mixdepth:</li> <li>Run several cjmtx of varying amounts with some makers. Amount variation is according to a statistical distribution as specified in the options.</li> <li>Run a final sweepjmtx spending all remaining utxos to the next mixdepth, or to a chosen external address if more than one external address is specified.</li> <li>Between each of these transactions is a randomised wait, again with a statistical distribution defined in the options.</li> <li>The final transaction sweep from the final mixdepth spends out to the (last) external address provided at the start, so is a sweepjmtx with a spend as described earlier.</li></ul> <p><strong>Pseudocode</strong>:</p> <div class="language- extra-class"><pre><code>load wallet
start msgchan
generate list of tumbler transactions
for each tx in list:
  read orders from pit
  read in tx variables: tx.N counterparties, tx.amount, tx.destaddr
  if tx.destaddr = 'ask':
    prompt user to provide address
  set transaction fee estimate
  choose orders using chosen algo
  send !fill message to chosen counterparties and do encryption handshake
  receive utxos
  construct template transaction and send to all counterparties
  receive signatures
  broadcast transaction to bitcoin network
  wait (lock) until 1 confirmation on network is seen
  wait tx.wait_time
</code></pre></div><p>Provision for failed makers is as specified in <a href="#handling-unresponsive-makers">handling unresponsive makers</a>, and provision is also made for the case where the orderbook has insufficient liquidity. The general philosophy is to not give up easily, as the code is usually intended to be running for a long time (a whole day is not uncommon).</p> <hr> <h1 id="messaging-layer"><a href="#messaging-layer" class="header-anchor">#</a> Messaging Layer</h1> <p>As mentioned in the section on <a href="#entities">Entities</a>, each participant in Joinmarket must connect to a messaging channel in order to communicate with other Joinmarket participants. The broad functionality, required for any messaging layer is (ordered by priority):</p> <ul><li>Both broadcast and private messaging</li> <li>Low latency (sub-second at least)</li> <li>Availability (including DOS resistance)</li> <li>Anonymity or facility thereof using common technologies (specifically, Tor)</li> <li>Scalability</li> <li>Censorship Resistance</li></ul> <p>Note that the list does <em>not</em> include encryption, because E2E encryption technology (including authentication and message integrity) can be used as a layer over the messaging channel. Thus while use of TLS for connection to the messaging layer may be desirable, it isn't necessary.</p> <p>Scalability is important due to the use of broadcast messages. It would be desirable to minimise this requirement; for example, using federated servers which publish orders out-of-band.</p> <p>Decentralization: not using centralized hubs/servers avoids trust issues and avoids potential censorship (can also help with availability, in some scenarios). Purely decentralized P2P messaging is a little difficult to achieve, especially for users who are not technically sophisticated (see: NAT punching).</p> <p>Censorship resistance must be strong against the peers themselves. For example in a pure p2p network the makers have an incentive to not forward offers from competing makers.</p> <p>The message channel's functionality is abstracted in the module <code>message_channel.py</code>. The message_channel class contains methods for <em>sending</em> messages and for <em>registering callbacks to receive messages</em>.</p> <h2 id="encrypted-messaging"><a href="#encrypted-messaging" class="header-anchor">#</a> Encrypted messaging</h2> <p>For the sake of privacy, it is required to end-to-end encrypt some part of the messages transferred between parties taking part in a coinjoin transaction. Note that this is not required for monetary security; that is handled by Bitcoin itself; technically it is also not <em>required</em> for coinjoin; a coinjoin in which the messages between participants are in plaintext over the wire would allow any passive observer to deduce the coin linkages, but not a future observer of the blockchain. Clearly, this distinction is somewhat academic and it would be highly undesirable to do coinjoins in this way entirely in plaintext over the wire.</p> <p>The technology used for this purpose is Daniel J Bernstein's <a href="https://nacl.cr.yp.to/" target="_blank" rel="noopener noreferrer">NaCl<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, which uses Curve25519 elliptic curve cryptography and the Salsa20 stream cipher, with Poly1305 as the MAC. The specific implementation of this is <a href="https://libsodium.org" target="_blank" rel="noopener noreferrer">libsodium<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, with the Python binding <a href="https://libnacl.readthedocs.org/en/latest/" target="_blank" rel="noopener noreferrer">libnacl<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>This was chosen for its wide usage, high reputation in the community and a design based on a philosophy of &quot;a highly secure default with as few options as possible&quot;. The particularly functionality used from the library is <a href="https://libnacl.readthedocs.org/en/latest/topics/public.html" target="_blank" rel="noopener noreferrer">authenticated encryption<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> using keys derived via <a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman" target="_blank" rel="noopener noreferrer">ECDH<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Note that nonces for encryption are chosen randomly per-message <strong>by default</strong> in libnacl. This is worthy of note as nonce-reuse would be a critical security weakness.</p> <p>For abstraction this functionality is exposed via a separate module in Joinmarket, <code>enc_wrapper.py</code> (this wrapper is currently entirely transparent).</p> <h2 id="messaging-handshake"><a href="#messaging-handshake" class="header-anchor">#</a> Messaging handshake.</h2> <p><strong>In the clear</strong> :</p> <div class="language- extra-class"><pre><code>TAK: !fill &lt;order id&gt; &lt;coinjoin amount&gt; &lt;taker encryption pubkey&gt;
MAK: !pubkey &lt;maker encryption pubkey&gt;
</code></pre></div><p>Both maker and taker construct a libnacl crypto <code>Box</code> object to allow authenticated encryption between the parties.
These Box objects are properties of the <code>CoinJoinTx</code> and <code>CoinJoinOrder</code> objects, so they are specific to
transactions and not to <code>Maker</code> and <code>Taker</code> entities.</p> <p><strong>Encrypted</strong> :</p> <div class="language- extra-class"><pre><code>TAK: !auth &lt;input utxo pubkey&gt; &lt;btc sig of taker encryption pubkey using input utxo pubkey&gt;
</code></pre></div><p>(Maker verifies the btc sig; if not valid, connection is dropped - send REJECT message)</p> <div class="language- extra-class"><pre><code>MAK: !ioauth &lt;utxo list&gt; &lt;coinjoin pubkey&gt; &lt;change address&gt; &lt;btc sig of maker encryption pubkey using coinjoin pubkey&gt;
</code></pre></div><p>(Taker verifies the btc sig; if not valid, as for previous)</p> <p>Because the <code>!auth</code> messages are under encryption, there is no privacy leak of bitcoin pubkeys or output addresses.</p> <p>If both verifications pass, the remainder of the messages exchanged between the two parties will continue under encryption.</p> <p>Specifically, these message types will be encrypted:</p> <ul><li><code>!auth</code></li> <li><code>!ioauth</code></li> <li><code>!tx</code></li> <li><code>!sig</code></li></ul> <p>Note on the above: A key part of the authorisation process is the matching between the bitcoin pubkeys used in the coinjoin transaction and the encryption pubkeys used. This ensures that the messages we are sending are only
readable by the entity which is conducting the bitcoin transaction with us. To ensure this, the maker should not sign any transaction that doesn't use the previously identified input utxo as its input, and the taker should not push/sign any transaction that doesn't use the previously identified maker coinjoin pubkey/address as its output.</p> <h2 id="messaging-protocol"><a href="#messaging-protocol" class="header-anchor">#</a> Messaging protocol.</h2> <p>See separate <a href="https://github.com/JoinMarket-Org/JoinMarket-Docs/blob/master/Joinmarket-messaging-protocol.md" target="_blank" rel="noopener noreferrer">document<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> TODO: Fix broken links.</p> <hr> <h1 id="blockchain-interface"><a href="#blockchain-interface" class="header-anchor">#</a> Blockchain Interface</h1> <p>The module <code>blockchaininterface.py</code> attempts to encapsulate all access to the Bitcoin blockchain, whether via a centralized API service or a local Bitcoin node.</p> <p>The abstract base class <code>BlockchainInterface</code> declares the following 6 abstract methods:</p> <div class="language- extra-class"><pre><code>@abc.abstractmethod
def sync_addresses(self, wallet):
    &quot;&quot;&quot;Finds which addresses have been used and sets
    wallet.index appropriately&quot;&quot;&quot;
    pass

@abc.abstractmethod
def sync_unspent(self, wallet):
    &quot;&quot;&quot;Finds the unspent transaction outputs belonging to this wallet,
    sets wallet.unspent &quot;&quot;&quot;
    pass

@abc.abstractmethod
def add_tx_notify(self, txd, unconfirmfun, confirmfun, notifyaddr):
    &quot;&quot;&quot;Invokes unconfirmfun and confirmfun when tx is seen on the network&quot;&quot;&quot;
    pass

@abc.abstractmethod
def pushtx(self, txhex):
    &quot;&quot;&quot;pushes tx to the network, returns txhash, or None if failed&quot;&quot;&quot;
    pass

@abc.abstractmethod
def query_utxo_set(self, txouts):
    &quot;&quot;&quot;
    takes a utxo or a list of utxos
    returns None if they are spend or unconfirmed
    otherwise returns value in satoshis, address and output script
    &quot;&quot;&quot;
    # address and output script contain the same information btw

@abc.abstractmethod
def estimate_fee_per_kb(self, N):
    '''Use the blockchain interface to 
    get an estimate of the transaction fee per kb
    required for inclusion in the next N blocks.
'''
</code></pre></div><p>Current, and any future, classes inheriting from <code>BlockchainInterface</code> must therefore implement these methods, which are more or less the required functionality for running either a <code>Maker</code> or a <code>Taker</code> entity in Joinmarket.</p> <p>The current implementations are:</p> <ul><li><code>BitcoinCoreInterface</code></li> <li><code>BlockrInterface</code></li> <li><code>RegtestBitcoinCoreInterface</code></li></ul> <p><code>BitcoinCoreInterface</code> is in some sense the most fundamental case: Joinmarket is really designed to be run with a Core node, as this is much better for privacy than using an SPV wallet or a web API interface. This point is emphasized in the <a href="https://github.com/JoinMarket-Org/joinmarket/wiki/Running-JoinMarket-with-Bitcoin-Core-full-node#running-joinmarket-with-bitcoin-core-full-node" target="_blank" rel="noopener noreferrer">Joinmarket wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p><code>RegtestBitcoinCoreInterface</code> is for testing using the regtest feature of Bitcoin Core. <code>RegtestBitcoinCoreInterface</code> inherits from <code>BitcoinCoreInterface</code> and adds a couple of extra features related to testing - the ability to trigger a new block, and the ability to make payments of arbitrary amounts of testnet coins to balances as required. There is more information on setup in <a href="https://github.com/JoinMarket-Org/joinmarket/wiki/Testing" target="_blank" rel="noopener noreferrer">this wiki page<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. This testing setup could be streamlined and improved, but the fundamental idea is important: it is possible to simulate an entire joinmarket trading pit using a local IRC daemon and a Bitcoin regtest daemon, without having to worry about use of real bitcoins.</p> <p><code>BlockrInterface</code> uses the API from <a href="https://btc.blockr.io" target="_blank" rel="noopener noreferrer">Blockr<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> to access blockchain data. Despite the strong caveats mentioned above, this is used by those without the patience or technical know-how to use Core.</p> <p>A detail worthy of mention is that Blockr's API does not expose the rpc <code>estimatefee</code> which is needed for the abstract method <code>BlockchainInterface.estimate_fee_per_kb</code>; for this, the API of <a href="http://dev.blockcypher.com" target="_blank" rel="noopener noreferrer">blockypher<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> is currently used, but it could of course change.</p> <p>It is of course likely and desirable that other implementations be developed, e.g. <code>BlocktrailInterface</code> relying on the <a href="https://blocktrail.com" target="_blank" rel="noopener noreferrer">Blocktrail<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> API. One could even envisage ameliorating privacy problems by mixing access to several (although this doesn't ameliorate, for example, the performance issue with polling web APIs).</p> <h2 id="the-notify-thread"><a href="#the-notify-thread" class="header-anchor">#</a> The Notify Thread</h2> <p>Both <code>Maker</code> and <code>Taker</code> entities need, in general, to be able to respond to the two principal &quot;events&quot; that can occur for a transaction on the Bitcoin blockchain: (1) transaction acceptance into a local memory pool and (2) transaction getting mined into a block for the first time. Of course (1) is a rather nebulous &quot;event&quot; since it's not global and not necessarily final, but for practical purposes it's treated as an event. As was discussed in the <a href="#maker">Maker</a> and <a href="#taker">Taker</a> sections, these events trigger callbacks <code>unconfirmfun</code> and <code>confirmfun</code>, which vary per entity. Triggering this requires &quot;listening&quot; to the blockchain.</p> <p>Thus, after a <code>Maker</code> or <code>Taker</code> has completed transaction negotiation with their counterparty, they access the global bc_interface (by calling <code>configure.jm_single().bc_interface</code>) and start a <code>NotifyThread</code>. This is done via a call to <code>add_tx_notify</code> (TODO why isn't this an abstract method? don't all blockchaininterface instances need it?).</p> <p>The call to <code>add_tx_notify</code> appends an entry to a list named <code>txnotify_fun</code>, which is a list of tuples of the format <code>(tx_output_set, unconfirmfun, confirmfun)</code>.</p> <p><strong>For BitcoinCoreInterface</strong>: On the first call to <code>add_tx_notify</code>, the <code>NotifyThread</code> thread is started. This thread starts an http server daemon, listening on the (host,port) specified in the configuration under section &quot;BLOCKCHAIN&quot; and settings &quot;notify_host&quot;, &quot;notify_port&quot;.</p> <p>The http daemon is an instance of <code>BaseHTTPServer.HTTPServer</code> and is instantiated with a class derived from <code>BaseHTTPServer.BaseHTTPRequestHandler</code> named <code>NotifyRequestHeader</code>. This class receives <code>HEAD</code> requests, specifically:</p> <div class="language- extra-class"><pre><code>/walletnotify?
/alertnotify?
</code></pre></div><p>This corresponds to configuration in BitcoinCore that allows it to make HTTP requests whenever a wallet 'event' occurs (the arrival of (unconfirm) or confirmation of a transaction which is connected to the wallet). Note that the addresses in the <strong>Joinmarket</strong> <a href="#wallets">wallet</a> are added as watch-only to Bitcoin Core, meaning that Core does not know their private keys but keeps track of them in a separate account. The account is named as</p> <div class="language- extra-class"><pre><code>joinmarket-XXXXXX
</code></pre></div><p>(XXXXXX = first 6 characters of the hex encoding of double-sha256 of the first address in the external branch of the first mixdepth of the Joinmarket wallet). Thus Bitcoin Core is set up to fire <code>walletnotify</code> when an event happens for the <code>Maker</code> or <code>Taker</code>'s wallet.</p> <p><code>alertnotify</code> is triggered by alerts in BitcoinCore, which happens very rarely. The information in the alert is passed on to Joinmarket and it is displayed on the terminal as well as in the logs.</p> <p>On subsequent calls, extra callbacks (<code>unconfirmfun</code> and <code>confirmfun</code>) are added to the <code>bc_interface.txnotify_fun</code> list, to be called for each blockchain event. Over long periods of operation therefore, a long list of such notify functions could accrue; but since this is just a list of function pointers, it isn't important.</p> <p>On reception of a <code>/walletnotify?txid</code> request, the <code>NotifyRequestHeader.do_HEAD</code> method is called, which checks the content of the transaction specified by <code>txid</code> by calling <code>getrawtransaction</code>, and then searches the set of elements of <code>BitcoinCoreInterface.notify_fun</code> to see if any of them contain the outputs of the transaction in their first element <code>tx_output_set</code> as described above. If so, it is those functions <code>unconfirmfun</code> and <code>confirmfun</code> which are the other two elements of the tuple in that list entry, which are called (which is called depends on whether the transaction data got from <code>getrawtransaction</code> shows the number of confirmations as zero or not).</p> <p><strong>For BlockrInterface</strong> :</p> <p>In this case, each call to <code>add_tx_notify</code> spawns a separate <code>NotifyThread</code> object. Hardcoded (currently) timeouts are used to decide when to stop listening for transaction arrival and confirmation:</p> <div class="language- extra-class"><pre><code>unconfirm_timeout = 10 * 60  # seconds
unconfirm_poll_period = 5
confirm_timeout = 2 * 60 * 60
confirm_poll_period = 5 * 60
</code></pre></div><p>This is unfortunately a necessary design; we must poll with API calls to the remote server to update the state. No doubt, there are more sophisticated and efficient designs that could be looked into.</p> <p>The thread is initiated with the transaction data and the specific <code>unconfirmfun</code> and <code>confirmfun</code> function pointers to trigger once the events occur on the blockchain.</p> <hr> <h1 id="bitcoin-transaction-fees"><a href="#bitcoin-transaction-fees" class="header-anchor">#</a> Bitcoin Transaction Fees</h1> <p>The earlier versions of Joinmarket used a fixed transaction fee, with a 10000 satoshi default and the ability to customise it by the Taker, using the <code>-f</code> option to <code>sendpayment.py</code> and <code>tumbler.py</code>. This is clearly not ideal, since the effectiveness of a particular transaction fee in allowing quick confirmation is a function of the size of the transaction in bytes. It was regularly observed that transactions are created with large size (say, 2-4 kB) and which were not being confirmed quickly.</p> <h2 id="fee-estimation-calculation"><a href="#fee-estimation-calculation" class="header-anchor">#</a> Fee Estimation Calculation</h2> <p>First, the size of a transaction in bytes must be estimated. This is currently found in <code>bitcoin.main.estimate_tx_size</code>, which shows the formula in comments:</p> <div class="language- extra-class"><pre><code>'''Estimate transaction size.
Assuming p2pkh:
out: 8+1+3+2+20=34, in: 1+32+4+1+1+~73+1+1+33=147,
ver:4,seq:4, +2 (len in,out)
total ~= 34*len_out + 147*len_in + 10 (sig sizes vary slightly)
'''
</code></pre></div><p>To expand: the 34 * (number of outputs in the bitcoin transaction) + 147* (number of inputs) + 10 is estimated as the size of the transaction in bytes. <strong>Note</strong> that this is not correct for p2sh transactions, but a separate more sophisticated calculation including the possibility of mixed p2pkh and p2sh utxos is not yet implemented.</p> <p>The output of this calculation is passed to <code>wallet.estimate_tx_fee()</code>, which takes the number of bytes and multiplies it by the estimated fee per kB (see the list of abstract methods in <a href="#blockchain-interface">BlockchainInterface</a>). The estimated fee per kB is dependent on the configuration variable set in the config section POLICY and the variable <code>tx_fees</code>, which (confusingly?) is the number of confirmations to target. Thus a relatively impatient Taker may set <code>tx_fees</code> to 1, to target confirmation in the next block, and a relatively patient taker may set it to 3 or more.</p> <hr> <h1 id="orders-and-the-trading-pit"><a href="#orders-and-the-trading-pit" class="header-anchor">#</a> Orders and the trading pit</h1> <p>The joinmarket 'pit' is where communication takes place in order to coordinate joins. Messages are <strong>broadcast</strong> to the pit to update the state of maker bots, and to request order information from Maker bots. See <a href="#orders">orders</a> below.</p> <p>Further coordination between proposed participants in a join happens using <strong>private</strong> (not broadcast messages) to individual <a href="#entities">entities</a>, and this process is described in the <a href="#messaging-layer">section</a> on the messaging layer, and the sub-document on the messaging <a href="https://github.com/joinmarket-org/joinmarket-docs/blob/master/Joinmarket-messaging-protocol.md" target="_blank" rel="noopener noreferrer">protocol<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>The Joinmarket pit broadcast layer is public information, and it can be viewed by anyone, for example it is currently available <a href="https://joinmarket.me/ob" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h2 id="public-entity-identities"><a href="#public-entity-identities" class="header-anchor">#</a> Public entity identities</h2> <p>Entities can connect to the pit over Tor, either directly or via the IRC hidden service. If future, different messaging layers than IRC are implemented, it is strongly intended to preserve this possibility (either using Tor or an equivalently strong anonymity layer). However direct network connections are also supported.</p> <p>Thus, entities are intended to be anonymous by default, but they can use persistent naming if they choose. The default naming of entities is using a simple randomised string, the code for which is currently in <code>joinmarket.irc.random_nick()</code>. Thus, by default, an entity's 'name' in the pit will change on every restart.</p> <h2 id="orders"><a href="#orders" class="header-anchor">#</a> Orders</h2> <p>Orders must be of a recognised type, currently one of:</p> <ul><li>relorder</li> <li>absorder</li></ul> <p>The list of valid order types is accessed in <code>joinmarket.configure.jm_single().ordername_list</code>. Orders of a type not included in this list will be ignored by Taker entities.</p> <p>Several parameters are to be included with the order, currently:</p> <ul><li><code>cjfee</code>: the amount, in percentage or satoshis, required for the Taker to pay the Maker.</li> <li><code>txfee</code>: the contribution, in satoshis, that the Maker will contribute to the overall Bitcoin transaction fee. Note: this may be deprecated in future version.</li> <li><code>minsize</code>: the minimum size of the coinjoin output, in satoshis, that the Maker will agree to.</li> <li><code>maxsize</code>: the maximum size of the coinjoin output, in satoshis, that the Maker will agree to.</li></ul> <p>The exact syntax of the messages to broadcast orders is found in the <a href="https://github.com/JoinMarket-org/joinmarket-docs/blob/master/Joinmarket-messaging-protocol.md" target="_blank" rel="noopener noreferrer">protocol doc<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <hr> <h1 id="the-configuration-file"><a href="#the-configuration-file" class="header-anchor">#</a> The Configuration File</h1> <p>Todo.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/joinMarketDocs/developers/ArchOverview.html" class="prev">
        ArchOverview
      </a></span> <span class="next"><a href="/joinMarketDocs/developers/Joinmarket-messaging-protocol.html">
        Joinmarket-messaging-protocol
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/joinMarketDocs/assets/js/app.e0a96047.js" defer></script><script src="/joinMarketDocs/assets/js/2.96e2a3f8.js" defer></script><script src="/joinMarketDocs/assets/js/10.8bb8a683.js" defer></script>
  </body>
</html>
